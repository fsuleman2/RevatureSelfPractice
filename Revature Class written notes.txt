DT: 29/06/2021
mark and sweep algo used for garbage collection,Mark the objecs and sweeps the memory in a rapid way.
java is bottom to top
compiler/Interpretor
src code -> fileName.java
given this file to javacompiler
javac(java Compiler) fileName.java
 
on Scuccess compilation we get
fileName.class(it Could be bytecode/object code/machine understandable code)

import java.util.Calendar; (Best Practice)
import java.util.*; (Bad Practice)
user defined package
package mypack; 
class MyClass{
}

.class in bin
src :  java code
____________________________________________
java use 'default' as default access modifer
public class FirstJavaClass{}
default : within the folder like ur friends within the package
private : only me
protect  means : relationship should be there
public : access everywhere
we can't have two public class in same .java file
we can have any number of default classes
we can't have private,protected classes as outer classes(ouside of class means class classname{psvm{}}), but we can have inner private protected public default static classes outside of main within the psvm.
classname and file name should be same
follow name convention => MyFirstJavaClass
compiler follow nameing convention for subclasses
mainclassname$subclassname
___________________________________________________
public static void main(String[] args){}
execution starts from main from { and ends at } whatever code we have will be executed.
why public : jre is outside so that he can enter into our class and execute our class
jvm resides in jre
why static : 
jvm gets memory from os and divide it into two parts
1) storage area ex: HDD/HEAP permanenet
2) execution area RAM/ STACK temp
whatever method/class bring it in stack and throw it back
all the non-static things will be in storage area
all the static things will be in execution area
in stack java inter preter resides. all static directly loaded into stack
you can accessed it without creating objects of it.

why not everything will be static?
java not 100% oops
2 resons
1. static voilating oops(says everyting should be acces via class and objects)
2. primitives datatypes
static : if we load eveyting memory get overflow
class product{
double price; //uncommon;
String pname; //uncommon;
static float discountonAll_product; //common
}

why void? : does not return anything

why main?  : just name of the method to start execution or we can say entry point
we can see entry point board on gate of mal,  we can say entry point.

why (String[] args) : why String only? : everyone will have their own mother tongue so same case here java mother tongue is String-> java READ/WRITE everything in STRING.
[] args ? : for passing multiple inputs thru commands
real life example debit card and ATM

____________________________
29/6/2021 3:34pm

Data Type => The one which describes type of the memory which I want to hold the data.
for every type comes with its own size.

Java has 8 primitive data types which are dynamically allocated.
int x = 100; 'x' is a variable of type int which having 4bytes of memory holding the value 100;
String s = "String";  's' is a object of String Class which is pointing to the reference(Memory address) of the Hello not the value.

8 data types and its size
(whole numbers)
1. byte 1-byte default value 0;

2. short 2-bytes default value 0

3. int 4-bytes default value 0

4. long 8-bytes default value 0L. must put L at the end otherwise considered as int.

(decimal values are larger than whole numbers)
5. float 4-bytes default value 0.00000f

6. double 8-bytes default value 0.00000f(any decimal values in java by default considered as double)

7. char 2-bytes '\u0000' why 2 bytes? : It supports 1-byte(ASCIII) and 1-byte(UNICODE) = 2-bytes.

8. boolean 1bit false by default/true
_________________________________________________
Type casting : conversion of one of the compatible types to another one.
1) Implicit: smaller size of type is assigned to larger size of type(taken care by the compiler)
ex:
double d = f; float to double
d = m //long to double 
f = x //int to float

2) Explicit : larger type in size when we assign it to smaller type in size (which should be done by programmer explicitely)
ex:
int c = 98 ;
char s = (char)c; //explicit
println(s); // b

float f1 = 22.44f;
int i = (int)f1;
println(i) // 22
long to int will be explicit
float to long will be implicit
to knw the range of int: 
println(Integer.MAX_VALUE); //similar for other primitives.

______________________________________________________________________
29/06/2021 4:02PM
public static_nonstatic_eg;
//importing the public static_nonstatic_eg2 for accessing that class
import static_nonstatic_eg2.Hello; //similar to  import java.util.Scanner;

public class Demo1{
public static void main(String[] args){
System.out.println("Hello from main");
iamStatic();
Demo1 d = new Demo1();
d.iamNonStatic();
d.iamNonStaticAgain();
Calculator.iamStatic() //static method of other class
Calculator  c = new Calculator();
c.iamNonStatic();
c.iamNonStaticAgain();

Hello h = new Hello();
h.iamNonStaticAgain(); //not accessible because there is no public beside that method,it took by default default.
}//main

public static void iamStatic(){
System.out.println("Iam static from same class");
}//iamStatic

public void iamNonStatic(){
System.out.println("Iam non static from demo1 class");
}//iamNonStatic
public void iamNonStaticAgain(){
System.out.println("Iam non static Again from demo1 class");
}//iamNonStaticAgain
}//demo1
_________________________________________________
Calculator.java //diff file but in same package
public static_nonstatic_eg;
public class Calculator
{
public static void iamStatic()
{
	System.out.println("Iam static from claculator same class");
}//iamStatic

public void iamNonStatic()
{
	System.out.println("Iam non static from calculator class");
}//iamNonStatic
public  void iamNonStaticAgain()
{
	System.out.println("Iam non static Again from Calulator class");
}//iamNonStaticAgain
}//calculator
==============================================================
Hello.java //from different package
package static_nonstatic_eg2;
public class Hello
{
public static void iamStatic()
{
	System.out.println("Iam static from claculator same class");
}//iamStatic

public void iamNonStatic()
{
	System.out.println("Iam non static from calculator class");
}//iamNonStatic

 void iamNonStaticAgain()
{
	System.out.println("Iam non static Again from Calulator class");
}//iamNonStaticAgain
}//hello class end
_________________________________________________________________
File Name : Product.java
Package Name : package static_nonstatic_eg3;

public class Product{
int x;
int y; 
//here x and y are called global object/instance level varibles
static int z; // z is called as global class level variable(Common to all objects)

public static void main(String[] args){

	Product p1 = new Product();
	p1.x = 99;
	p1.y = 100;
	System.out.println("Printing for p1");
	p1.printXYZ();

	Product p2 = new Product();
	p2.x = 66;
	p2.y = 100000;
	p2.z = 8888;
	System.out.println("Printing for p2");
	p2.printXYZ();

	System.out.println("Printing for p1 again");
	p1.printXYZ();

}//main

public void printXYZ()
{
	System.out.println("x = "+x);
	System.out.println("y = "+y);
	System.out.println("z = "+z);

}//printXYZ
}//product
local var is shawdod with global var by using 'this' keyword
default value of any object is null
rightclick>source>generateconstructorsforallfields
constructor chaining should be in one line
__________________________________________________________________________________________________________________
30/06/2021 10:08AM
overriding is possible only when there is parent child relationship
single : one parent one child
Hierarchical Inheritance : one parent 3childs all inherit from one parent
multilevel inheritance : parent<c1<c2
mutiple : sup1 sup2 sub class inherits from bth not supported in java
hybrid (hie+multi/any two things together hybrid) not supported in java
object class is the superclass of all the classes
objname.getclass() //use to print package and classname
objname.gethashcode //print hashcode of a class
java follows bottom-up approcah
constructor invoking is from top to bottom
interpretor goes top to bottom line by line.
________________________________________________________________
In method overloading return type could be anything, only thing is parameters should be different.
@overriding : 
modification of a existing feature of a parent in child class
we can override sub class method in subclass itself
all this done at runtime. because memory is allocated at runtime.

we can't override anything which is static.(bcoz we can access static with obj only which is related to object can be ovveride)
final methods also can't be override.
for doing ovverind there must be parent child relationship, same name and paras. only updating behaviour in child class of a parent method.
parent method and child method visibility(access modifier) should be same. but u cannot decrease the visibility means(if parent is public then we can't have child method as protected or others bcoz public is higher than all of them)
public>protected>default>private
annotaion comes into picture from java v7
what is annotations?
basically it reminds the developer there is a typo mismatch in the method name of the parent and child class.
we can make it remind them by using
@Override just above the override method in child class.first letter should be caps of annotations
____________________________________________________________________
3:46pm
object casting : Where a child class object will be converted to parent and vice versa.
when inheritance then only we can cast object.
there are two types of object casting:
1) Implicit casting : taken care by the compiler smaller -> Bigger
Bigger = parent class, Smaller - child class.
MobileV3 v3 = new MobileV3();
Object o = v3;
o can access its own methods and if any of his methods are overridden/updated in child.

2)Explicit casting larger to - > smaller
MobileV1 v1 = (MobileV1)o;
v1 can access his methods and his parents methods and any of his methods if it is updated or overridden in the child class.
 
Object o = new MobileV2(); //implicit
Object o = v3; //implicit
4:42
where do we apply above concept?
ans: for comparing two objects we are using
comparison operators only for primitive datatypes
if do then it will compare memeory adress

____________________________________________________________________________________________
5:09
Abstraction: a class is said to be an abstract class if it having at least one abstract method.
abstract won't have any body so we can't create object of abstract methods
abstract methods cannot be static(alreeady defined n loaded) or final
abstract class dont have constructors
abstraction can be achieved by using interface concept.
abstract methods can have abstract methods as well non abstract methods
by creating the object of child class we can call abstract class methods. make sure thaat your subclass should be non abstract.
abstract method/class can have access to any access modifer but can't downgraded it
___________________________________________________________________
01/07/2021
10:00AM
using constructors u can't update everytime bcoz it agains create objects.
so we take help of setters and getters to update fields manyway.

All Abstract, default and static methods in an interface are implicitly PUBLIC,
so u can omit the public modifier.
All constants values defined in an interface are impi PUBLIC,

STATIC AND FINAL. u can omit public.
Abstract:                                      Interface
1. abstract class uses abstract keyword        1. Interface use interface as keywords to define themselves they are just class itself
2. We can extend only one class		       2. We can implement any number of interfaces
3. any class default visibi will be default    3. any variables declared in interface is considered as static and final
4. to make anything as static and final in     4. No Constructors
   in classes we must use those keywords	
5. We can have overloaded constructors which   5. no such thing 
   can be invoked by the child class constr
   using super class
6. for classes we use extends keyword	       6. implements keyword

from java8 it is allowed to have default methods in interface.
anthing which is abstract cannot be instantiTED rather we use chid clas 

//L.H.S should be interface and right hand side should
	//be its implementing class(code to interface) 

1.An interface can extends another interface
public interface childInterface extends ParentInterface{}
if we want to implement innerInterface we need to do
public class Imp1 implements ChildInterface, ChildInterface.InnerInterface{}


2. We can have innerclasses in interface
public class imp1 extends ChildInterface.Innerclass{}

3. Static methods allowed in interfaces from JAVA 8
mising one point

Interface are of 3 types
1) Normal Interface : Interface with any number of abstract methods in it.
2) Functional Interface : with only and only one abstract method but u can have any number of non abstract methods.
3) Marker Interface : Interface with no abstract methods at all, which is use by compiler to mark that it does some job.
eg: serilizable

//Lamda Expression (->) it is used to give the defination for abstract method of funtional Interface only.
it is only use for functional interface
we use @FunctionalInterface annotation before the public interface HelloFromFn1{}
by using we functional interface we can have multiple defination for same method.
we will be dealing with marker interface in files concepts.
_____________________________________________________________________________________
1:05 Wrappers and String Class
Java5- Collections relased.
will accept only and only objects
int -> integer
int x = 10;
Integer i = 10; // i is refereing to addres of x
comes in java.lang package.
Integer is a class
Integer.MAX_VALUE here integer is a class and Max_VALUE IS METHOD.
for STRINGS AND 8 WRAPPER CLASSES so we dont have to use new keyword over there bcoz we have common string pool in heap given by jvm.
String  s = "Hello"; //no new keyword req
s4 = s4.intern(); //brings s4 from heap general memeory to string common pool.
.equlasIgnoreCase() will ignore case senitive hello and Hello will be True;
.equals() // strictly case sensitive hello and Hello will be false
String s1 = "hello"
s1.startsWith("he");  true
s1.endsWith("llo"); true
s1.constains("ello"); /true
s1.contains("lol"); //false
s1.contains("e"); tryue
if u assign s1.replace("l","m") then it will replce else it will remain hello
Integer i = 10; //no new keyword req
object will point to adress of value
String s4 = new String("hey");
devloper want sperate memory inside heap but outside common string pool.
in case of string == checks the memory adrress
in case of string .equals() checks the value

autoboxing : int x = 100;
	     Integer i1 = x;
automatically encapsulating the primitive to its equivalent wrapper class.
compareTo():
_____________________________________________________________________________________
3:37PM
character wrapper class
String s = "A S d    !@_ dsk1239AX1iK>_f";
character demo methods pending
_________________________________________________________
Reg-Ex - 
[] = represents expression
{} = represents length
^ = not
[a-z]{3} = any 3 lower case character are accepted
[A-Z0-9]{5} = any combination of 5 uppercase with digits are accepted
[A-z]{5}[0-9]{4} = five Upper case letters followed by 4 digits.
[a-zA-Z]{2,8} = any word of min length of 2 and max length of 8
[0-9]{1,} = minimum length is 1 and max can be infinite
[^0-9] = apart from digits anything

String s = "JKHPS1586P";
if(s!=null && s.matches("[A-Z]{5}[0-9]{4}[A-Z]{1}"))
	println("Valid PAN");
else
	println("NOT VALID");

Task- write regex for all the govt id's you have(license,uid,bikenumber)
____________________________________________________________________________________
4:16pm- StringBuffer and StringBuilder
String and StringBuffer and StringBuilder are final classes coz they don't have any parent child
relationship.
- StringBuffer and StringBuilder are mutable objects
- They can update in same memory itself.
- There is no common pool for these both which means you must create them using new keyword only.
- StringBuffer and StringBuilder are Thread Safe
______________________________________________________________________________________________
02/07/2021 10:15AM
Arrays println("arr["+i+"] : "+arr[i]);
1. Collection of Similar type
2. Comtiguos memeory location(0->N)
3. Fixed Size(Static in nature)
4. Insertion and Deletion in any position
5. Indexed Based
6. Initiliazed all the locations will be filled with default values of that particular type,
   incase of string and objects default value stored will be null.

foreach loop
for(int x : arr){}
System.out.println(Arrays.toString(arr)) //will print all arrays ele without using loops.
System.out.println(Arrays.binarySearch(arr,position)); //not benifi if duplicate ele there

//copy of array
int arr1[] = Arrays.copyOf(ar,ar.length+10);
println(Arrays.toString(arr1));

//fill for arr1 by default as -1
Arrays.fill(arr1,-1);
println(+Arrays.toString(ar1));

//equals method
Arrays.equals(arr1,arr2); //compares with index and values should be same

//Tasks: 1. Find all the palindrome in an array
	 2. Find all Prime numbers in an array
	 3. Find average of even and odd numbers in array
	 4. Find the characters of a string which are in prime index postion and print them in uppercase
	 5. Find if all the vowels are present in an String or not.
	 6. Find if all the vowels in a proper order of AEIOU is present in string or not.
	 7. Remove all the duplicates in an array
	 8. Remove all the duplicate character from a string
	 9. Print the number which is occuring highest number of times in an array.
	10. Print the 2nd highest number in an array(there will be duplicates)
2-D ARRAY later we will do it
_____________________________________________________________________________________
11:39AM-> Exceptional Handling

Exception Handling
--------------------------
What is error? What is Exception?
*error is a non recoverable situation.
*exception is something which can be handled and can continue the same
flow of execution.
* basically in any application due to user's input or due to
our logical error it may lead to abnormal termination of a application which
is a very bad practise, an application which terminates abnormally
is considered as 0 quality app and nobody wishes to buy or get such
application.
*Exception handling will help you handle the exceptions which has been
raised and terminate normally with the proper communication to the
end user, where such app which handles all the abnormal status normally
its the app which is sold highest in any market.
*It is always encouraged to write a better exceptional handling to get
a better review or quality about the product.
* There are set of predefined exceptions and there can be created 
some of userdefined or custom exceptions for fulfilling business requirement
too.
* All the predefined Exceptions comes under Throwable class.
* and java.lang.Exception is a super class for all the exceptions
in java.
*There are 2 types of exceptions
  a)Checked Exception(java.lang.Exception) -> this exception forces the progarmmer to handle it
 			at the compile time itself, until the programmer
			handles it, compiler wont allow to run.
			some of Checked exceptions are
			FileNotFoundException, ClassNotFoundException,
			MethodNotFoundException, SQLException and more.
  b)Unchecked Exceptions(java.lang.RuntimeException) -> These exceptions are part of java.lang.RunTimeException
                         which occurs at a run time, it is upto programmer
			weather he wants to handle this or not, if he
			doesnt handle it, it will lead to abnormal termination.
                      few unchecked exceptions are:
			ArithmeticException, NullPointerException,
                        ConcurrentModificationException,
			ArrayIndexOutOfBoundException,
                        StringIndexOutOfBoundException and more.
Exceptions can be handled using:
1)try...catch...finally
2)throws
3)throw 

1)try...catch...finally
---------------------------------
* try is a block of code where we keep the code which is suspected to
generate a exception.
*catch is a handler which handles the exception raised by try block.
*finally is such block of code which is executed despite of exception is 
caught or not, we can use such block to clear our resources.
*a try block should and must be followed by catch or finally, 
u cannot write try alone.
*there can be any number of catch blocks for a single try which should be
written in the order i.e the child class exception should come first and
followed by the rest.
*finally and try will be a single block.
*if no catch you can even write finally, if there is a catch then 
finally comes at the end of all catch blocks.


2)throws
---------------
used to throw multpile exceptions at the method level to the calling method.
use it to force the programmer who is creating the object for that
method will handle it.


3)throw
---------------
used to create the exception object of our own to throw our own customised
exception with our own customised message.



Any app in the world having 3 Layers
1. Presentation Layer(presentation logics to beautify/UI)
2. Business or Application Layer(All the complex logic here)
3. Storage or Persistance or DB Layer (Databse SQL/NO SQL)

Object
1)Throwable
1a) Error
1b) Exception superclass for all the exception
checked exception: happens when compiler is expecting error and want programmer to handle it. until you don't handle it I won't fix that.


____________________________________________________________________
3:38PM Helper Class java.util.Collections; sort(),binarySearch() 
Collections basicallly tries to give solution to a given problem
how? let see
Arrays are of fixed size,having similar type, contiguos memory location, CRUD operations are lengthy.
========Collections Framework===========
- Dynamic in Nature
- Accepts only objects
- Resizable (Don't have to define size)
- anytype(Object)
- Iterable(Don't have to use for loop to see the content,
  we can see it easily using iterator obj).
Root for All the collection is Collection Interface except MAP
1)Iterable
A) Collection<E>(I)
1a) List<E>(I) has three providers i)Vectors<E>(I) uses array internally ii) ArrayList<E>(I) uses arrrays internally iii) LinkedList<E>() uses node like structure to maintain the data.
1b) Queue<E>(I)
1c) Set<E>(I)

I = Interface
E = Generic Type = wil give type compatibility
C = Class

Collection is a root for all the collections and collections is a utility class.

i)Vectors<E>(I) 
- uses array internally
- By default it gives 10 memeory loc, after 10 gets full it will add 10 more.
- Contiguous
-legacy thread safe

ii) ArrayList<E>(I) 
- uses arrrays internally
- resizing capacity 10-> newmem = old + 50%old=10+5=15
  total will be prev 10 + newmem = 25
- not thread safe

iii) LinkedList<E>() 
- uses node like structure to maintain the data.
- resizing capa -> 1 node at a time
- not thread safe
.add()
.set() // update
.get() //get particular ele
.remove() //accept both objects and primitive
.size() //size of ele
.clear() //to clear the list.
.addAll(listname_obj) //union all
list2.retainAll(li1) //intersection of li2 and li1, results will be stored in li2
li2.removeAll(li1) // like a-b operation contents of a which are not there in b will be removed and results will be stored in a.    

some helper classes
Collections.reverse(li1);
Collection.shuffle(li1); //everytime we referesh it will shuffle elements
Collections.replace(li1,null,-1);
Collection.sort(li1); //ascending by default make sure you dont have any null values
//print in descending
Collections.sort(li1,Collections.reverseOrder()); //it is an overloaded method
Collections.sort(li1);
Collections.binarySearch(li1,23);
li1.contains(100); //true searches and print true if there.
_____________________________________________________
Task- compare the LL and PriorityQuee and come up with code exmple.
________________________________________________
Set<E>(I)
it is unique,unindexed & unordered = internal order(Hashing order generated by hashing object).
1a) HashSet<E>(C) -> i) LinkedHashSet<E>(C)
1b) SortedSet<E>(I) i)NavigableSet<E>(I) i1)TreeSet<E>(C)
all three will be having 16mem location only
- every mem acts as binary tree(much more faster way)
- It will allow only one null value.
- no duplicates no replace shot here.
- hash will not maintained order.
- linked mentained order os set by DLL
- Tree is in sorted order by default and with the help of BST (asc/dse)
  we can pass null values in Trees.  output is in alphabet order.   
.add() //for adding elements
.remove("hi");
treeset.contains("hibernate") //true
.addAll()
.retainAll()
.removeAll()
treeset.size()  
//for removing duplicates.
List<String> list =  Arrays.asList("hello","hello","abc");
Set<String> set = new TreeSet<>(list);
s.o.pln(set)           