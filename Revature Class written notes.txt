DT: 29/06/2021
mark and sweep algo used for garbage collection,Mark the objecs and sweeps the memory in a rapid way.
java is bottom to top
compiler/Interpretor
src code -> fileName.java
given this file to javacompiler
javac(java Compiler) fileName.java
 
on Scuccess compilation we get
fileName.class(it Could be bytecode/object code/machine understandable code)

import java.util.Calendar; (Best Practice)
import java.util.*; (Bad Practice)
user defined package
package mypack; 
class MyClass{
}

.class in bin
src :  java code
____________________________________________
java use 'default' as default access modifer
public class FirstJavaClass{}
default : within the folder like ur friends within the package
private : only me
protect  means : relationship should be there
public : access everywhere
we can't have two public class in same .java file
we can have any number of default classes
we can't have private,protected classes as outer classes(ouside of class means class classname{psvm{}}), but we can have inner private protected public default static classes outside of main within the psvm.
classname and file name should be same
follow name convention => MyFirstJavaClass
compiler follow nameing convention for subclasses
mainclassname$subclassname
___________________________________________________
public static void main(String[] args){}
execution starts from main from { and ends at } whatever code we have will be executed.
why public : jre is outside so that he can enter into our class and execute our class
jvm resides in jre
why static : 
jvm gets memory from os and divide it into two parts
1) storage area ex: HDD/HEAP permanenet
2) execution area RAM/ STACK temp
whatever method/class bring it in stack and throw it back
all the non-static things will be in storage area
all the static things will be in execution area
in stack java inter preter resides. all static directly loaded into stack
you can accessed it without creating objects of it.

why not everything will be static?
java not 100% oops
2 resons
1. static voilating oops(says everyting should be acces via class and objects)
2. primitives datatypes
static : if we load eveyting memory get overflow
class product{
double price; //uncommon;
String pname; //uncommon;
static float discountonAll_product; //common
}

why void? : does not return anything

why main?  : just name of the method to start execution or we can say entry point
we can see entry point board on gate of mal,  we can say entry point.

why (String[] args) : why String only? : everyone will have their own mother tongue so same case here java mother tongue is String-> java READ/WRITE everything in STRING.
[] args ? : for passing multiple inputs thru commands
real life example debit card and ATM

____________________________
29/6/2021 3:34pm

Data Type => The one which describes type of the memory which I want to hold the data.
for every type comes with its own size.

Java has 8 primitive data types which are dynamically allocated.
int x = 100; 'x' is a variable of type int which having 4bytes of memory holding the value 100;
String s = "String";  's' is a object of String Class which is pointing to the reference(Memory address) of the Hello not the value.

8 data types and its size
(whole numbers)
1. byte 1-byte default value 0;

2. short 2-bytes default value 0

3. int 4-bytes default value 0

4. long 8-bytes default value 0L. must put L at the end otherwise considered as int.

(decimal values are larger than whole numbers)
5. float 4-bytes default value 0.00000f

6. double 8-bytes default value 0.00000f(any decimal values in java by default considered as double)

7. char 2-bytes '\u0000' why 2 bytes? : It supports 1-byte(ASCIII) and 1-byte(UNICODE) = 2-bytes.

8. boolean 1bit false by default/true
_________________________________________________
Type casting : conversion of one of the compatible types to another one.
1) Implicit: smaller size of type is assigned to larger size of type(taken care by the compiler)
ex:
double d = f; float to double
d = m //long to double 
f = x //int to float

2) Explicit : larger type in size when we assign it to smaller type in size (which should be done by programmer explicitely)
ex:
int c = 98 ;
char s = (char)c; //explicit
println(s); // b

float f1 = 22.44f;
int i = (int)f1;
println(i) // 22
long to int will be explicit
float to long will be implicit
to knw the range of int: 
println(Integer.MAX_VALUE); //similar for other primitives.

______________________________________________________________________
29/06/2021 4:02PM
public static_nonstatic_eg;
//importing the public static_nonstatic_eg2 for accessing that class
import static_nonstatic_eg2.Hello; //similar to  import java.util.Scanner;

public class Demo1{
public static void main(String[] args){
System.out.println("Hello from main");
iamStatic();
Demo1 d = new Demo1();
d.iamNonStatic();
d.iamNonStaticAgain();
Calculator.iamStatic() //static method of other class
Calculator  c = new Calculator();
c.iamNonStatic();
c.iamNonStaticAgain();

Hello h = new Hello();
h.iamNonStaticAgain(); //not accessible because there is no public beside that method,it took by default default.
}//main

public static void iamStatic(){
System.out.println("Iam static from same class");
}//iamStatic

public void iamNonStatic(){
System.out.println("Iam non static from demo1 class");
}//iamNonStatic
public void iamNonStaticAgain(){
System.out.println("Iam non static Again from demo1 class");
}//iamNonStaticAgain
}//demo1
_________________________________________________
Calculator.java //diff file but in same package
public static_nonstatic_eg;
public class Calculator
{
public static void iamStatic()
{
	System.out.println("Iam static from claculator same class");
}//iamStatic

public void iamNonStatic()
{
	System.out.println("Iam non static from calculator class");
}//iamNonStatic
public  void iamNonStaticAgain()
{
	System.out.println("Iam non static Again from Calulator class");
}//iamNonStaticAgain
}//calculator
==============================================================
Hello.java //from different package
package static_nonstatic_eg2;
public class Hello
{
public static void iamStatic()
{
	System.out.println("Iam static from claculator same class");
}//iamStatic

public void iamNonStatic()
{
	System.out.println("Iam non static from calculator class");
}//iamNonStatic

 void iamNonStaticAgain()
{
	System.out.println("Iam non static Again from Calulator class");
}//iamNonStaticAgain
}//hello class end
_________________________________________________________________
File Name : Product.java
Package Name : package static_nonstatic_eg3;

public class Product{
int x;
int y; 
//here x and y are called global object/instance level varibles
static int z; // z is called as global class level variable(Common to all objects)

public static void main(String[] args){

	Product p1 = new Product();
	p1.x = 99;
	p1.y = 100;
	System.out.println("Printing for p1");
	p1.printXYZ();

	Product p2 = new Product();
	p2.x = 66;
	p2.y = 100000;
	p2.z = 8888;
	System.out.println("Printing for p2");
	p2.printXYZ();

	System.out.println("Printing for p1 again");
	p1.printXYZ();

}//main

public void printXYZ()
{
	System.out.println("x = "+x);
	System.out.println("y = "+y);
	System.out.println("z = "+z);

}//printXYZ
}//product
local var is shawdod with global var by using 'this' keyword
default value of any object is null
rightclick>source>generateconstructorsforallfields
constructor chaining should be in one line
__________________________________________________________________________________________________________________
30/06/2021 10:08AM
overriding is possible only when there is parent child relationship
single : one parent one child
Hierarchical Inheritance : one parent 3childs all inherit from one parent
multilevel inheritance : parent<c1<c2
mutiple : sup1 sup2 sub class inherits from bth not supported in java
hybrid (hie+multi/any two things together hybrid) not supported in java
object class is the superclass of all the classes
objname.getclass() //use to print package and classname
objname.gethashcode //print hashcode of a class
java follows bottom-up approcah
constructor invoking is from top to bottom
interpretor goes top to bottom line by line.
________________________________________________________________
In method overloading return type could be anything, only thing is parameters should be different.
@overriding : 
modification of a existing feature of a parent in child class
we can override sub class method in subclass itself
all this done at runtime. because memory is allocated at runtime.

we can't override anything which is static.(bcoz we can access static with obj only which is related to object can be ovveride)
final methods also can't be override.
for doing ovverind there must be parent child relationship, same name and paras. only updating behaviour in child class of a parent method.
parent method and child method visibility(access modifier) should be same. but u cannot decrease the visibility means(if parent is public then we can't have child method as protected or others bcoz public is higher than all of them)
public>protected>default>private
annotaion comes into picture from java v7
what is annotations?
basically it reminds the developer there is a typo mismatch in the method name of the parent and child class.
we can make it remind them by using
@Override just above the override method in child class.first letter should be caps of annotations
____________________________________________________________________
3:46pm
object casting : Where a child class object will be converted to parent and vice versa.
when inheritance then only we can cast object.
there are two types of object casting:
1) Implicit casting : taken care by the compiler smaller -> Bigger
Bigger = parent class, Smaller - child class.
MobileV3 v3 = new MobileV3();
Object o = v3;
o can access its own methods and if any of his methods are overridden/updated in child.

2)Explicit casting larger to - > smaller
MobileV1 v1 = (MobileV1)o;
v1 can access his methods and his parents methods and any of his methods if it is updated or overridden in the child class.
 
Object o = new MobileV2(); //implicit
Object o = v3; //implicit
4:42
where do we apply above concept?
ans: for comparing two objects we are using
comparison operators only for primitive datatypes
if do then it will compare memeory adress

____________________________________________________________________________________________
5:09
Abstraction: a class is said to be an abstract class if it having at least one abstract method.
abstract won't have any body so we can't create object of abstract methods
abstract methods cannot be static(alreeady defined n loaded) or final
abstract class dont have constructors
abstraction can be achieved by using interface concept.
abstract methods can have abstract methods as well non abstract methods
by creating the object of child class we can call abstract class methods. make sure thaat your subclass should be non abstract.
abstract method/class can have access to any access modifer but can't downgraded it
___________________________________________________________________
01/07/2021
10:00AM
using constructors u can't update everytime bcoz it agains create objects.
so we take help of setters and getters to update fields manyway.

All Abstract, default and static methods in an interface are implicitly PUBLIC,
so u can omit the public modifier.
All constants values defined in an interface are impi PUBLIC,

STATIC AND FINAL. u can omit public.
Abstract:                                      Interface
1. abstract class uses abstract keyword        1. Interface use interface as keywords to define themselves they are just class itself
2. We can extend only one class		       2. We can implement any number of interfaces
3. any class default visibi will be default    3. any variables declared in interface is considered as static and final
4. to make anything as static and final in     4. No Constructors
   in classes we must use those keywords	
5. We can have overloaded constructors which   5. no such thing 
   can be invoked by the child class constr
   using super class
6. for classes we use extends keyword	       6. implements keyword

from java8 it is allowed to have default methods in interface.
anthing which is abstract cannot be instantiTED rather we use chid clas 

//L.H.S should be interface and right hand side should
	//be its implementing class(code to interface) 

1.An interface can extends another interface
public interface childInterface extends ParentInterface{}
if we want to implement innerInterface we need to do
public class Imp1 implements ChildInterface, ChildInterface.InnerInterface{}


2. We can have innerclasses in interface
public class imp1 extends ChildInterface.Innerclass{}

3. Static methods allowed in interfaces from JAVA 8
mising one point

Interface are of 3 types
1) Normal Interface : Interface with any number of abstract methods in it.
2) Functional Interface : with only and only one abstract method but u can have any number of non abstract methods.
3) Marker Interface : Interface with no abstract methods at all, which is use by compiler to mark that it does some job.
eg: serilizable

//Lamda Expression (->) it is used to give the defination for abstract method of funtional Interface only.
it is only use for functional interface
we use @FunctionalInterface annotation before the public interface HelloFromFn1{}
by using we functional interface we can have multiple defination for same method.
we will be dealing with marker interface in files concepts.
_____________________________________________________________________________________
1:05 Wrappers and String Class
Java5- Collections relased.
will accept only and only objects
int -> integer
int x = 10;
Integer i = 10; // i is refereing to addres of x
comes in java.lang package.
Integer is a class
Integer.MAX_VALUE here integer is a class and Max_VALUE IS METHOD.
for STRINGS AND 8 WRAPPER CLASSES so we dont have to use new keyword over there bcoz we have common string pool in heap given by jvm.
String  s = "Hello"; //no new keyword req
s4 = s4.intern(); //brings s4 from heap general memeory to string common pool.
.equlasIgnoreCase() will ignore case senitive hello and Hello will be True;
.equals() // strictly case sensitive hello and Hello will be false
String s1 = "hello"
s1.startsWith("he");  true
s1.endsWith("llo"); true
s1.constains("ello"); /true
s1.contains("lol"); //false
s1.contains("e"); tryue
if u assign s1.replace("l","m") then it will replce else it will remain hello
Integer i = 10; //no new keyword req
object will point to adress of value
String s4 = new String("hey");
devloper want sperate memory inside heap but outside common string pool.
in case of string == checks the memory adrress
in case of string .equals() checks the value

autoboxing : int x = 100;
	     Integer i1 = x;
automatically encapsulating the primitive to its equivalent wrapper class.
compareTo():
_____________________________________________________________________________________
3:37PM
character wrapper class
String s = "A S d    !@_ dsk1239AX1iK>_f";
character demo methods pending
_________________________________________________________
Reg-Ex - 
[] = represents expression
{} = represents length
^ = not
[a-z]{3} = any 3 lower case character are accepted
[A-Z0-9]{5} = any combination of 5 uppercase with digits are accepted
[A-z]{5}[0-9]{4} = five Upper case letters followed by 4 digits.
[a-zA-Z]{2,8} = any word of min length of 2 and max length of 8
[0-9]{1,} = minimum length is 1 and max can be infinite
[^0-9] = apart from digits anything

String s = "JKHPS1586P";
if(s!=null && s.matches("[A-Z]{5}[0-9]{4}[A-Z]{1}"))
	println("Valid PAN");
else
	println("NOT VALID");

Task- write regex for all the govt id's you have(license,uid,bikenumber)
____________________________________________________________________________________
4:16pm- StringBuffer and StringBuilder
String and StringBuffer and StringBuilder are final classes coz they don't have any parent child
relationship.
- StringBuffer and StringBuilder are mutable objects
- They can update in same memory itself.
- There is no common pool for these both which means you must create them using new keyword only.
- StringBuffer and StringBuilder are Thread Safe
______________________________________________________________________________________________
02/07/2021 10:15AM
Arrays println("arr["+i+"] : "+arr[i]);
1. Collection of Similar type
2. Comtiguos memeory location(0->N)
3. Fixed Size(Static in nature)
4. Insertion and Deletion in any position
5. Indexed Based
6. Initiliazed all the locations will be filled with default values of that particular type,
   incase of string and objects default value stored will be null.

foreach loop
for(int x : arr){}
System.out.println(Arrays.toString(arr)) //will print all arrays ele without using loops.
System.out.println(Arrays.binarySearch(arr,position)); //not benifi if duplicate ele there

//copy of array
int arr1[] = Arrays.copyOf(ar,ar.length+10);
println(Arrays.toString(arr1));

//fill for arr1 by default as -1
Arrays.fill(arr1,-1);
println(+Arrays.toString(ar1));

//equals method
Arrays.equals(arr1,arr2); //compares with index and values should be same

//Tasks: 1. Find all the palindrome in an array
	 2. Find all Prime numbers in an array
	 3. Find average of even and odd numbers in array
	 4. Find the characters of a string which are in prime index postion and print them in uppercase
	 5. Find if all the vowels are present in an String or not.
	 6. Find if all the vowels in a proper order of AEIOU is present in string or not.
	 7. Remove all the duplicates in an array
	 8. Remove all the duplicate character from a string
	 9. Print the number which is occuring highest number of times in an array.
	10. Print the 2nd highest number in an array(there will be duplicates)
2-D ARRAY later we will do it
_____________________________________________________________________________________
11:39AM-> Exceptional Handling
07/02/2021 01:15:19 PM

Exception Handling
--------------------------
What is error? What is Exception?
*error is a non recoverable situation.
*exception is something which can be handled and can continue the same
flow of execution.
* basically in any application due to user's input or due to
our logical error it may lead to abnormal termination of a application which
is a very bad practise, an application which terminates abnormally
is considered as 0 quality app and nobody wishes to buy or get such
application.
*Exception handling will help you handle the exceptions which has been
raised and terminate normally with the proper communication to the
end user, where such app which handles all the abnormal status normally
its the app which is sold highest in any market.
*It is always encouraged to write a better exceptional handling to get
a better review or quality about the product.
* There are set of predefined exceptions and there can be created 
some of userdefined or custom exceptions for fulfilling business requirement
too.
* All the predefined Exceptions comes under Throwable class.
* and java.lang.Exception is a super class for all the exceptions
in java.
*There are 2 types of exceptions
  a)Checked Exception(java.lang.Exception) -> this exception forces the progarmmer to handle it
 			at the compile time itself, until the programmer
			handles it, compiler wont allow to run.
			some of Checked exceptions are
			FileNotFoundException, ClassNotFoundException,
			MethodNotFoundException, SQLException and more.
  b)Unchecked Exceptions(java.lang.RuntimeException) -> These exceptions are part of java.lang.RunTimeException
                         which occurs at a run time, it is upto programmer
			weather he wants to handle this or not, if he
			doesnt handle it, it will lead to abnormal termination.
                      few unchecked exceptions are:
			ArithmeticException, NullPointerException,
                        ConcurrentModificationException,
			ArrayIndexOutOfBoundException,
                        StringIndexOutOfBoundException and more.
Exceptions can be handled using:
1)try...catch...finally
2)throws
3)throw 

1)try...catch...finally
---------------------------------
* try is a block of code where we keep the code which is suspected to
generate a exception.
*catch is a handler which handles the exception raised by try block.
*finally is such block of code which is executed despite of exception is 
caught or not, we can use such block to clear our resources.
*a try block should and must be followed by catch or finally, 
u cannot write try alone.
*there can be any number of catch blocks for a single try which should be
written in the order i.e the child class exception should come first and
followed by the rest.
*finally and try will be a single block.
*if no catch you can even write finally, if there is a catch then 
finally comes at the end of all catch blocks.


2)throws
---------------
used to throw multpile exceptions at the method level to the calling method.
use it to force the programmer who is creating the object for that
method will handle it.


3)throw
---------------
used to create the exception object of our own to throw our own customised
exception with our own customised message.



Any app in the world having 3 Layers
1. Presentation Layer(presentation logics to beautify/UI)
2. Business or Application Layer(All the complex logic here)
3. Storage or Persistance or DB Layer (Databse SQL/NO SQL)

Object
1)Throwable
1a) Error : like ur application got crashed which u can't handle.
1b) Exceptionclass is the superclass for all the exception.
checked exception: Checked Exception happens when compiler is expecting error and want programmer to handle it. until you don't handle it I won't fix that.
Any class that is a direct child of EXCeption class is called Exception
eg: FileNotFoundException, ClassNotFoundException, SQLException, ParseExeption
another direct class of class Exception is RuntimeException(unChecked Exception)
RuntimeException(UnChecked Exception) : are the exception in which compiler don't force programmer to handle it,programmer has its choice either it handle it by using try catch or use some logic or right code in such a way that it does not cause error.

eg: ArithmeticException, NullPointerExeption, ClassCastException,ConcurrentModificationException,
IndexOutOfBoundException(ArrayIndexOutOfBound and StringIndexOutOfBoundException)

*if you want to create your own custom CheckedException
____________________________________________________________________
3:38PM Helper Class java.util.Collections; sort(),binarySearch() 
Collections basicallly tries to give solution to a given problem
how? let see
Arrays are of fixed size,having similar type, contiguos memory location, CRUD operations are lengthy.
========Collections Framework===========
- Dynamic in Nature
- Accepts only objects
- Resizable (Don't have to define size)
- anytype(Object)
- Iterable(Don't have to use for loop to see the content,
  we can see it easily using iterator obj).
Root for All the collection is Collection Interface except MAP
1)Iterable
A) Collection<E>(I)
1a) List<E>(I) has three providers i)Vectors<E>(I) uses array internally ii) ArrayList<E>(I) uses arrrays internally iii) LinkedList<E>() uses node like structure to maintain the data.
1b) Queue<E>(I)
1c) Set<E>(I)

I = Interface
E = Generic Type = wil give type compatibility
C = Class

Collection is a root for all the collections and collections is a utility class.

i)Vectors<E>(I) 
- uses array internally
- By default it gives 10 memeory loc, after 10 gets full it will add 10 more.
- Contiguous
-legacy thread safe

ii) ArrayList<E>(I) 
- uses arrrays internally
- resizing capacity 10-> newmem = old + 50%old=10+5=15
  total will be prev 10 + newmem = 25
- not thread safe

iii) LinkedList<E>() 
- uses node like structure to maintain the data.
- resizing capa -> 1 node at a time
- not thread safe
.add()
.set() // update
.get() //get particular ele
.remove() //accept both objects and primitive
.size() //size of ele
.clear() //to clear the list.
.addAll(listname_obj) //union all
list2.retainAll(li1) //intersection of li2 and li1, results will be stored in li2
li2.removeAll(li1) // minus like a-b operation contents of a which are not there in b will be removed and results will be stored in a.    

some helper classes
Collections.reverse(li1);
Collection.shuffle(li1); //everytime we referesh it will shuffle elements
Collections.replace(li1,null,-1);
Collection.sort(li1); //ascending by default make sure you dont have any null values
//print in descending
Collections.sort(li1,Collections.reverseOrder()); //it is an overloaded method
Collections.sort(li1);
Collections.binarySearch(li1,23);
li1.contains(100); //true searches and print true if there.
_____________________________________________________
Task- compare the LL and PriorityQuee and come up with code exmple.
________________________________________________
Set<E>(I)
it is unique,unindexed & unordered = internal order(Hashing order generated by hashing object).
1a) HashSet<E>(C) -> i) LinkedHashSet<E>(C)
1b) SortedSet<E>(I) i)NavigableSet<E>(I) i1)TreeSet<E>(C)
all three will be having 16mem location only
- every mem acts as binary tree(much more faster way)
- It will allow only one null value.
- no duplicates no replace shot here.
- hash will not maintained order.
- linked mentained order os set by DLL
- Tree is in sorted order by default and with the help of BST (asc/dse)
  we can't pass null values in Trees thru nullptrexce.  output is in alphabet order.   
.add() //for adding elements
.remove("hi");
treeset.contains("hibernate") //true
.addAll()
.retainAll()
.removeAll()
treeset.size()  
//for removing duplicates.
List<String> list =  Arrays.asList("hello","hello","abc");
Set<String> set = new TreeSet<>(list);
s.o.pln(set)
__________________________________________
5/july/2021
10:30am
Map Interface: 
A Map is an associative array data structre. "Key" -> Value
HashMap is one of the implementation of Map Interface.
*Map is a part of Collections f/w but not under Collection interface.
*Map comes with Key and Value pair where every Value is dependent on the Key.
*Key is unique and value can be duplicated.
* it is unindexed an unordered.
*Map is implemented in HashMap,LinkeHashMap,TreeMap and Hashtable classes.
KeySet() : Group of keys
values() : Group of Values
entrySet() : a record it called entry(key and value) //college n list of students unique and repeated
1)Map<K,V>(I)
1a) HashMap<K,V>(C)
i) LinkedHashMap<K,V>(C)
only deiff between the hashmap and linked hashmap
hash does not maintained order of insertion where as linkedhashmap maintain the order of insertion

1b)SortedMap<K,V>(I)
i)NavigableMap<K,V>(I)
ii)TreeMap<K,V>(C)

*It implements Map, SortedMap and NavigableMap interfaces.
*not synch
* maintains the order of a key by using Comparable/Comparator object.
* key cant be null, any number of values can be null.
* since its sorted its faster for searching n traversing.

1c) Hashtable<K,V>(C) 
-neither key nor value null here
-all the legacy classes are by default Synchronised and thread safe.
-No insetion order
*It implements Map.
* generally known as no null Map or no null table i.e neither a key nor
   a value can be null over here.
*it is thread safe.
* it wont maintain the order of insertion.
_____________________________________________________________________
Map<Integer, String> hm =  new HashMap<>();
hm.put(100,"Java");
hm.put(100,"updated") // it will update from java to updated if we insert another value for a same key
hm.put(null,"jre"); //only one key can be null
hm.put(190,null)
hm.put(190,null) //any no. of values can be null
same above in LinkedHashMap except linkedHashMap preserve the Insertion Order.
Map<Integer,String> lhm = new LinkedHashMap<>();
in TreeMap we can't even insert one null value also, if we do we get error.
In HashTable we can't insert neither of one KEY and Value as NULL.
methods:
ht.put(key,value)
ht.get(key) // returns value
ht.size() //return size of ht
ht.remove(key) //if key gone value also gone.
ht.containsKey(key) //returns true or false
ht.containsValue(value) //returns true or false
ht.keySet() //will give all the keys from hash table
ht.values() // give all the values 
==========================================
How would u iterate one by one? lets c.
-> first extract it into set
Set<Integer> set =  ht.keySet();
for(Integer i : set){
	syso("Key = "+i+" Value = "+he.get(i));
}
---------------------------------------------
another way to iterate thru hashmap
for(Entry<Integer,String> e : ht.entrySet())
{
	syso("Key -> "+e.getKey()+" Value -> "+e.getValue());
}
---------------------------------------------------
Problem sttmt: General common to all Collections
// Remove all key value pairs of any key which is null or any value which is null or if any key is divisible by 10
let say we have this data

Map<Integer, String> hm =  new HashMap<>();
hm.put(100,"Java");
hm.put(100,"updated");
hm.put(1000,"null");
hm.put(2000,"jdk");
hm.put(10,"JavaScript");
hm.put(11,"null");
hm.put(199,"Java1");
hm.put(null,"jre");
for(Entry<Integer,String> e : hm.entryString()){
if(e.getKey() == null || e.getValue() == null || e.getKey()%10==0){
hm.remove(e.getKey()); //concurrentmodification exception
by two objects we are doing two diff operation so getting concu exception.
}
}//fail fast
fail safe
to avoid this exception we are using Enumerator
Enumerator - > read operation from T-B
Iterator - >  read and remove from T-B
ListIterator - > specifically design for List Interface and it can do
add, read, and remove and its Bi-directional.
.hasNext() //check wheather there is any key value pair there or not
.next() read and look for next
____________________________________________________________________
Comparable and Comparator are functional Interfaces.
- T = Functional Interface has only and only one abstract method.
***************Diff comparable and comparator**************
Comparable<T> : Comparator <T> use for SORTING custom objects
java.lang : java.util
int compareTo(Object o); : int compare(Object 01,Object o2);
within the POJO class : defination can be anywhere
compareTo() : compare()
Task : try above with Treeset
Task : repeat same using Product(id,manufacturername, pname,cost,ratings,availability-yes/no) from scractch.
_______________________________________________________________________
12:55pm
Stream API's : 
.stream()
.filter()
.map()
var args - variable number of arguments
you can pass 0 to N number of args of same type
rules : we cannot have 2 var args as params for a method signature
...a ...b wrong you cannot have only
-> You can have any number of normal params but they should be var args i.e var args should be the list in the param list
_______________________________________________________________________________________
FILES CONCEPTS / IO STREAMS
ParentClass:IOStreams
1) ByteStream(byte by byte)
i) InputStream as abstract class
ia) FileInputStream
provided with buckets to process faster
BufferedInputStream

ii) OutputStream as abstract class
iia) FileOutputStream
BufferedOutputStream
we use ObjectInputStream
as java is oops lang
we use ObjectOutputStream for stroing the file objs
2)CharacterStream(char by char)unicode
i) Reader class
ia)FileReader
- BufferedReader

ii) Writer Class
iib) FileWriter
- BufferedWriter
from java 7 try() we can write in try we can skip finaaly block if we use try with resources
InputStream                 OutputStream
**ByteStream(does reading nd writing byte by byte) - InputStream->FileInputStream, BufferedInputStream
	     OutputStream->FileOutputStream, BufferedOutputStream
In bytestream whenever u wanna write data to file u have to convert ur data
to bytes and then u have to write it to the destination.
While reading also the stream gives u byte. convert in into char to get your desired
output.
**CharacterStream(does reading and writing caharacter by character)
	      - Reader -> FileReader,BufferedReader
	      - Writer -> FileWriter, BufferedWriter
In char stream no need to convert it while u read and write.

Note: Use Buffer in both the Byte and Char streams to speed up the reading and
writing process.
_____________________________________________________________________________________________________
3:19PM 
Serialization : 
--------------
serializing and de-serializing a particular object/s in some
persistant area.
Serilizable-- Interface 0 abstract methods
ObjectOutputStream - writeObject
ObjectInputStream - readObject
transient(use this if u dont want to serialize a particular object in a serialized class)
Marker Interface - > Serializable
transient  = anyobject which is sensitve which can be put that keyword cvv
________________________________________________________
Scanner class:
best Practice
int age = Integer.parseInt(sc.nextLine());
syso(age);
_________________________________________________________
Iterable and iterator
_____________________________________________________________
Multithreading:
start() invokes run() {what thread exactly do}
once it reaches Runnable it ready to execute what ever we are wrting in run() that is exeuted
executing run() is called as Running state.
some times it is interrupted
MultiThreading
--------------------------------------
* set of instructions is a program -> any program under exceution is a process
  -> part of this process or tiny process or smallest job of a process
  is basically called as thread. group of these threads sharing the load of 
 process and doing some job parallelly in an application, such app
 we call it as multithreaded app.
*thread basically will help u acheive parallel programming i.e simultaneously
u can do multiple jobs and make your app much smarter and much faster.
remember the app which is faster is appreciated in the market and we have
more customers or clients basically for such app.
* for eg take a MS Word which is actually multithreaded app. so msword is
a process which gets created when u double click on it, so now ur
working on this word doc u do a spelling mistake, for this u have a thread
within a word app which highlights your mistake in red color so that u can
go ahead and correct your spelling, and parallely if u have missed ur grammer
green line u can see coming up between the text asking u to fix your sentence
with proper grammer.
* by default all the java app is single threaded, i.e main is a
application thread created by java.
* when u create a group of threads they are in a race condition to run
and finish their jobs, in which u cant identify which thread is coming
first and which is last.
* whenever a thread gets created in java it will be having 3 things with it
[thread_name,priority,thread_group]  [main,5,main]
priority by default will be 5 or it depends on the thread which is
creating this thread, which ever thread is creating a thread the priority
of that particular thread will be passed to new thread.
MIN_PRIORITY - 1
NORM_PRIORITY - 5
MAX_PRIORITY - 10
*thread has a life cycle -> you have to create a thread i.e you have
to give a name, priority an group for a thread, next phase it will be put into
runnable phase where thread is been checked weather it has permission to
access or not, when thread starts to do its job we call thread is in
running phase, in this running phase it has interrupts which may be
generated to wait or to sleep or if some thread with higher priority is coming
in, once thread completes its running phase it dies.
*remember thread will be given the memory which has been allocated to process and
every thread will be having its own private stack to maintain the data of
the particular thread. 
*there are basically 2 types of thread
a)application/foreground thread - these threads which are designed to manage the
                       foreground operations, the jvm will wait for all these
			threads to complete the job and then only it will exit.
b)deamon/background thread - these threads run in a background of our app mostly
                       desgined for releasing resources or memory, jvm will
			never wait for any background thread to finish the job.
			if all the foreground threads are done with the job
			jvm will exit no matter at that time any background
			thread is running or not. for eg : garbage collector.
*in java, threads can be implemented in 2 ways
a)by extending java.lang.Thread class - where you have all the thread life 
                                        cycle based methods.
b)by implementing java.lang.Runnable interface(preffered) - where you have only
					run() method in which you will give the
					job of thread.
* the threads default behaviour of being in a race condition wont be helpful
when there are commonly shared resources, so you can build a synchronized
block or a method where you can keep the shared data, in this block or
a method only one thread is allowed at a time, until that thread
releases the lock, other thread cant acquire that particular block.
*every thread in a java will be having a unique ID, using which jvm
tracks the behaviour of it, all the status and behaviours are being
managed using ThreadMonitors in java.
*start() is a method using which we can start a particular thread which will
call the run() method. in run() method is what you will be giving the
job of what exactly that thread should do.
---------------------------------------------------------------------
to know where current thread is running is
syso(Thread.currentThread());
//creating thread
Thread t = Thread.currentThread();
t.setName("my main");
t.setPriority(7); //priorities must be in between 1 to 10
Syso(Thread.currentThread()) // Thread[MyThread,7,main]
//creating my own threadclass
public class myThread extends Thread{
@Overide
public void run(){
syso("hello"+Thread.currentThread());
}
.join() : Thread class provides the join() method which allows one thread to wait until another thread completes its execution. 
If t is a Thread object whose thread is currently executing, 
then t. join() will make sure that t is terminated before the next instruction is executed by the program.
synchronized(){}
//explore wait,notify, notifyall()
//try producer-consumer problem